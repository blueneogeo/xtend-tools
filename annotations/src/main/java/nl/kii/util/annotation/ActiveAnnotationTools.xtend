package nl.kii.util.annotation

import java.util.List
import org.eclipse.xtend.lib.macro.TransformationContext
import org.eclipse.xtend.lib.macro.declaration.MethodDeclaration
import org.eclipse.xtend.lib.macro.declaration.MutableClassDeclaration
import org.eclipse.xtend.lib.macro.declaration.MutableMethodDeclaration
import org.eclipse.xtend.lib.macro.declaration.MutableTypeParameterDeclaration
import org.eclipse.xtend.lib.macro.declaration.TypeParameterDeclaration
import org.eclipse.xtend.lib.macro.declaration.TypeReference

/**
 * Tools for creating Active Annotations.
 */
class ActiveAnnotationTools {

	val extension TransformationContext context

	new(TransformationContext context) {
		this.context = context
	}
	
	/** Shortcut for context.newTypeReference(cls) */
	def TypeReference ref(Class<?> cls, TypeReference... types) {
		cls.newTypeReference(types)
	}

	/**
	 * Create a copy of a typereference that adds references to any used types by name.
	 * Solves the issue of copying the type parameters from one method to another.
	 * The newMethodTypeParams can be generated by the copyMethodTypeParameters() method in this class.
	 */
	def TypeReference add(TypeReference originalType, Iterable<? extends TypeParameterDeclaration> newMethodTypeParams) {
		// is it a wildcard?
		if(originalType.isWildCard) return originalType
		// is it a direct type reference?
		val t = newMethodTypeParams.findFirst [ simpleName == originalType.simpleName ]
		if(t != null) return t.newTypeReference
		// try subtype reference
		val subtypes = originalType.actualTypeArguments.map [ add(newMethodTypeParams) ]
		originalType.type.newTypeReference(subtypes)
	}

	/** 
	 * Create a copy of an existing method signature, but without the body.
	 * Provides you with a closure that allows you to alter the new method and create the body.
	 * @param targetCls: the class to create the copy on
	 * @param sourceCls: the class that contains the source method
	 * @param newName: if not null, if the existing class method is not static and contains the same signature, rename the method
	 * @param copyAnnotations : if true, also copy all annotations from the original method
	 * @param copyParameters: if true, also copy all parameters (including generic types) from the original method
	 * @param transformationFn: closure that takes the new method and method type parameters and can modify it before adding to the targetCls 
	 */
	def MutableMethodDeclaration addMethodCopy(MutableClassDeclaration targetCls, TypeReference sourceCls, MethodDeclaration sourceMethod, String methodName, boolean copyAnnotations, boolean copyParameters, (MutableMethodDeclaration, List<? extends MutableTypeParameterDeclaration>)=>void methodTransformerFn) {
		// make sure we don't create a double copy
		targetCls.addMethodSafely(if(methodName != null) methodName else sourceMethod.simpleName) [
			val newMethod = it
			// set the basic properties of the new method
			primarySourceElement = sourceMethod
			static = sourceMethod.static
			final = sourceMethod.final
			varArgs = sourceMethod.varArgs
			visibility = sourceMethod.visibility
			deprecated = sourceMethod.deprecated
			docComment = '''
				«sourceMethod.docComment»
				Original class types: «sourceMethod.parameters.map [ type.extractTypeParameterNames ].flatten»
				Generated extension method of  «sourceMethod.signature»
				@see «sourceCls»#«sourceMethod.simpleName»(«FOR p : sourceMethod.parameters SEPARATOR ','»«p.simpleName»«ENDFOR») «sourceMethod.simpleName»
			''' 
			exceptions = sourceMethod.exceptions
			synchronized = sourceMethod.synchronized
			// add all types from the original method to the new method
			for(type : sourceCls.actualTypeArguments) {
				newMethod.addTypeParameter(type.simpleName)
			}
			for(type : sourceMethod.typeParameters) {
				newMethod.addTypeParameter(type.simpleName)
			}
			// if this is a static extension method, also detect the types being used 
			// in the class from the used parameters and add them to the method
			// bit of a hack... but no way found yet to extract type parameters from a class typereference
			if(!sourceMethod.static) {
				val methodTypeParameterNames = sourceMethod.extractTypeParameterNamesFromSignature
				val existingTypeParameterNames = sourceMethod.typeParameters.map [ simpleName ].toList
				methodTypeParameterNames.removeAll(existingTypeParameterNames)
				for(typeParamName : methodTypeParameterNames) {
					newMethod.addTypeParameter(typeParamName)
				}
			}
			// copy annotations 
			if(copyAnnotations) {
				for(annotation : sourceMethod.annotations) {
					addAnnotation(annotation)
				}
			}
			// copy parameters
			if(copyParameters) {
				if(!sourceMethod.static) {
					static = true
					val instanceName = sourceCls.simpleName.toFirstLower
					addParameter(instanceName + 'Instance', sourceCls)					
				}
				for(parameter : sourceMethod.parameters) {
					addParameter(parameter.simpleName, parameter.type.add(newMethod.typeParameters))
				}
			}
			returnType = sourceMethod.returnType.add(newMethod.typeParameters)
			methodTransformerFn.apply(it, newMethod.typeParameters.toList)
		]
	}
	
	/** Only add a new method if it does not already exist */	
	def MutableMethodDeclaration addMethodSafely(MutableClassDeclaration cls, String simpleName, (MutableMethodDeclaration)=>void initializer) {
		val newMethod = cls.addMethod(simpleName, initializer)
		if(cls.newTypeReference.hasDuplicateMethod(newMethod, false)) {
			newMethod.remove
			null
		} else {
			newMethod
		}
	}
	
	// STATIC METHODS /////////////////////////////////////////////////////////	

	/** Tests if the type is the same or extends another type */
	def static extendsType(TypeReference type, TypeReference sameOrSuperType) {
		sameOrSuperType.isAssignableFrom(type)
	}
	
	/** Find all method type parameters being references that we could not find in the method declaration. Only use when creating extension methods. */
	private def extractTypeParameterNamesFromSignature(MethodDeclaration originalMethod) {
		val extractedParameterTypeNames = originalMethod.parameters.map [ type.extractTypeParameterNames ].flatten
		val extractedReturnTypeNames = originalMethod.returnType.extractTypeParameterNames
		val allExtracted = extractedParameterTypeNames + extractedReturnTypeNames
		allExtracted.toSet
	}

	/** 
	 * <li>Promise<T, Map<A, B>> should result in #[T, A, B]
	 * <li>T should result in #[T]
	 * 
	 * Cheats, tries to identify type parameters by being uppercase only...
	 * However, it is impossible to extract them from a class typereference.
	 */
	def static Iterable<String> extractTypeParameterNames(TypeReference type) {
		if(type.actualTypeArguments.empty) {
			if(type.simpleName == type.simpleName.toUpperCase) #[ type.simpleName ] else #[]
		}
		else type.actualTypeArguments.map [ extractTypeParameterNames ].flatten
	}

	/** 
	 * Check if the cls has a duplicate signature of the method being passed.
	 * @param cls the class to check
	 * @param method the method we use to check the signature from
	 * @param includeSuperClasses if true, also include superclasses of cls for matching method signatures
	 */
	def static boolean hasDuplicateMethod(TypeReference cls, MethodDeclaration method, boolean includeSuperClasses) {
		val clsMethods = if(includeSuperClasses) cls.allResolvedMethods else cls.declaredResolvedMethods
		val matchingMethods = clsMethods.filter [ declaration.hasSameSignatureAs(method) ]
		matchingMethods.size > 1
	}

	/**
	 * Check if method1 and method2 have the same signature (name and parameter types)
	 */
	def static hasSameSignatureAs(MethodDeclaration method1, MethodDeclaration method2) {
		if(method1.simpleName != method2.simpleName) return false
		if(method1.parameters.size != method2.parameters.size) return false
		if(method1.parameters.empty) return true
		for(var i = 0; i < method1.parameters.size; i++) {
			val p1 = method1.parameters.get(i)
			val p2 = method2.parameters.get(i)
			if(p1.type.name != p2.type.name) return false
		}
		true
	}

	/** Print out the signature of a method: <pre>name(param-type,param-type,...)<pre> */
	def static String signature(MethodDeclaration method) {
		'''«method.simpleName»(«FOR param : method.parameters SEPARATOR ','»«param.type.simpleName»«ENDFOR»)'''
	}
	
}
